#ifndef PINTERNAL_H
# define PINTERNAL_H

# include "./types.h"

// ==========================Abstract Syntax Tree (AST)==========================
/**
 * @brief Creates a new AST node.
 *
 * Allocates and initializes a new AST node from a token.
 *
 * @param tok The token.
 * @return A pointer to the new node, or NULL on failure.
 */
t_astnode	*new_astnode(t_token *tok);

/**
 * @brief Adds a child node to a parent node.
 *
 * Maintains a circular doubly-linked list of children.
 *
 * @param parent The parent node.
 * @param child The child node to add.
 */
void		add_child(t_astnode *parent, t_astnode *child);

/**
 * @brief Parses the token stream generated by the lexer.
 *
 * Creates an Abstract Syntax Tree (AST) from the tokens.
 * Performs syntactic analysis.
 *
 * @param l A pointer to the lexer.
 * @return A pointer to the root of the AST, or NULL on error
 *         or if input is empty.
 */
t_astnode	*parse(t_lexer *l);

// =====================================UTILS=====================================
/**
 * @brief Frees the entire AST.
 *
 * Recursively deallocates all nodes in the tree.
 *
 * @param node A pointer to the root node pointer.
 */
t_astnode	*parse_exec(t_token *token);
t_astnode	*parse_redir(t_token **token);
t_astnode	*parse_logical_exp(t_token **token);
t_astnode	*parse_pipe(t_token **token);
void		free_ast(t_astnode **node);
void		print_ast(t_astnode *node, int depth);
// ==========================Abstract Syntax Tree (AST)===========================

// =====================================LEXER=====================================
/**
 * @brief Main lexing function, generates tokens.
 *
 * Iterates through input, creates tokens based on chars.
 *
 * @param l Pointer to the lexer struct.
 */
void		generate_tokens(t_lexer	*l);

/**
 * @brief Skips whitespace characters in the input.
 *
 * Advances the lexer's position past any spaces, tabs.
 *
 * @param l Pointer to the lexer struct.
*/
void		eat_whitespaces(t_lexer *l);

/**
 * @brief Reads the next character from the input.
 *
 * Updates the lexer's current character and position.
 *
 * @param l Pointer to the lexer struct.
 */
void		read_char(t_lexer *l);

/**
 * @brief Peeks at the next character in the input.
 *
 * Without advancing the lexer's position.
 *
 * @param l Pointer to the lexer struct.
 * @return The next character, or 0 if at the end.
*/
char		peek_char(t_lexer *l);

/**
 * @brief Appends a new token to the lexer's token list.
 *
 * Creates and adds a token to the circular doubly-linked list.
 *
 * @param l Pointer to the lexer struct.
 * @param type The type of the token to add.
 * @param size The size (length) of the token's literal.
 * @return 0 on success, 1 on failure.
 */
int			append_token(t_lexer *l, t_token_type type, int size);

/* Creates new token with literal and type
 * literal must be null terminated
 * Advanes lexer postion by advance 
 * */
int	append_advance(t_lexer *l, char *literal, unsigned int advance, t_token_type type);

/**
 * @brief Analyzes the tokens for syntax errors.
 *
 * This is assumed based on usage in `parse`.
 *
 * @param l Pointer to the lexer.
 * @return int 0 on success any other number otherwise.
*/
int			analyze_tokens(t_lexer *l);

/**
 * @brief Gets the position of the next whitespace.
 *
 * Calculates distance to the next whitespace or end.
 *
 * @param l Pointer to the lexer struct.
 * @return Distance to next whitespace or end of input.
 */
int			get_pos_next_whitespace(t_lexer *l);


// ================================TOKEN CREATION=================================
int			lex_env_var(t_lexer *l);
int			lex_keyword(t_lexer *l);
int			lex_executable(t_lexer *l);
int			lex_word(t_lexer *l);
int			lex_quote(t_lexer *l);

// =====================================UTILS=====================================
/**
 * @brief Checks if a token matches any type in an array.
 *
 * @param token The token to check.
 * @param expected An array of expected token types.
 * @param size The number of elements in `expected`.
 * @return True if the token matches, false otherwise.
 */
bool		match(t_token *token, t_token_type expected[], int size);
t_lexer		*new_lexer(const char *str);
t_token		*new_token(t_token_type t, t_lexer *l, int size);
void		free_lexer(t_lexer *l);
void		print_tokens(t_token *token);
char		*decode(t_token_type t);
bool		is_token_exec(t_token_type t);
// =====================================LEXER=====================================

// =====================================EXTRA=====================================
bool		is_letter(char c);
bool		ft_isspace(char ch);
int			is_there_exec(t_lexer *l);
// =====================================EXTRA=====================================

#endif
