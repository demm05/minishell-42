#ifndef PINTERNAL_H
# define PINTERNAL_H

# include "./types.h"

// ==========================Abstract Syntax Tree (AST)==========================
/**
 * @brief Creates a new AST node.
 *
 * Allocates and initializes a new AST node from a token.
 *
 * @param tok The token.
 * @return A pointer to the new node, or NULL on failure.
 */
t_astnode	*new_astnode(t_token *tok);

/**
 * @brief Adds a child node to a parent node.
 *
 * Maintains a circular doubly-linked list of children.
 *
 * @param parent The parent node.
 * @param child The child node to add.
 */
void		add_child(t_astnode *parent, t_astnode *child);

/**
 * @brief Parses the token stream generated by the lexer.
 *
 * Creates an Abstract Syntax Tree (AST) from the tokens.
 * Performs syntactic analysis.
 *
 * @param l A pointer to the lexer.
 * @return A pointer to the root of the AST, or NULL on error
 *         or if input is empty.
 */
t_astnode	*parse(t_lexer *l);

// =====================================UTILS=====================================
/**
 * @brief Frees the entire AST.
 *
 * Recursively deallocates all nodes in the tree.
 *
 * @param node A pointer to the root node pointer.
 */
t_astnode	*parse_exec(t_token *token);
t_astnode	*parse_redir(t_token **token);
t_astnode	*parse_logical_exp(t_token **token);
t_astnode	*parse_pipe(t_token **token);
void		free_ast(t_astnode **node);
void		print_ast(t_astnode *node, int depth);
// ==========================Abstract Syntax Tree (AST)===========================

// =====================================LEXER=====================================
/**
 * @brief Main lexing function, generates tokens.
 *
 * Iterates through input, creates tokens based on chars.
 *
 * @param l Pointer to the lexer struct.
 */
void		generate_tokens(t_lexer	*l);

/**
 * @brief Skips whitespace characters in the input.
 *
 * Advances the lexer's position past any spaces, tabs.
 *
 * @param l Pointer to the lexer struct.
*/
void		eat_whitespaces(t_lexer *l);

/**
 * @brief Reads the next character from the input.
 *
 * Updates the lexer's current character and position.
 *
 * @param l Pointer to the lexer struct.
 */
void		read_char(t_lexer *l);

/**
 * @brief Peeks at the next character in the input.
 *
 * Without advancing the lexer's position.
 *
 * @param l Pointer to the lexer struct.
 * @return The next character, or 0 if at the end.
*/
char		peek_char(t_lexer *l);

/**
 * @brief Appends a token to the lexer's token list
 *
 * If the list is empty, initializes the list with the new token.
 * Implements a circular doubly-linked list structure for tokens.
 *
 * @param l Pointer to a lexer structure that contains the token list
 * @param new Pointer to the new token to append
 *
 * @return 1 if there is any fail 
 * @return Implicitly returns on successful append
 */
int	append_token(t_lexer *l, t_token *new_token);

/**
 * Allocates memory for a string, copies characters from the lexer's input starting at the current position,
 * and appends the token to the lexer's token list.
 *
 * @param l Pointer to a lexer structure
 * @param type The type of token to create
 * @param size The number of characters to copy from the input
 *
 * @return 1 if lexer pointer is NULL, memory allocation fails, or appending the token fails
 * @return Result of append_token on success
 *
 * @note This function allocates memory for the string literal that will be stored in the token.
 *       The lexer is responsible for freeing this memory when the token is no longer needed.
 */
int	append_alloc(t_lexer *l, t_token_type type, int size);

/**
 * @brief Creates a new token and advances the lexer's position
 *
 * Creates a new token with the specified literal and type, advances the lexer's position
 * by the specified amount, and appends the token to the lexer's token list.
 *
 * @param l Pointer to a lexer structure
 * @param literal String literal to associate with the token (must be null-terminated)
 * @param advance Number of positions to advance the lexer after creating the token
 * @param type The type of token to create
 *
 * @return 1 if lexer pointer is NULL, creating the token fails, or appending the token fails
 * @return Result of append_token on success
 */
int	append_advance(t_lexer *l, char *literal, unsigned int advance, t_token_type type);

/**
 * @brief Analyzes the tokens for syntax errors.
 *
 * This is assumed based on usage in `parse`.
 *
 * @param l Pointer to the lexer.
 * @return int 0 on success any other number otherwise.
*/
int			analyze_tokens(t_lexer *l);

/**
 * @brief Gets the position of the next whitespace.
 *
 * Calculates distance to the next whitespace or end.
 *
 * @param l Pointer to the lexer struct.
 * @return Distance to next whitespace or end of input.
 */
int			get_pos_next_whitespace(t_lexer *l);


// ================================TOKEN CREATION=================================
int			lex_env_var(t_lexer *l);
int			lex_keyword(t_lexer *l);
int			lex_executable(t_lexer *l);
int			lex_word(t_lexer *l);
int			lex_quote(t_lexer *l);

// =====================================UTILS=====================================
/**
 * @brief Checks if a token matches any type in an array.
 *
 * @param token The token to check.
 * @param expected An array of expected token types.
 * @param size The number of elements in `expected`.
 * @return True if the token matches, false otherwise.
 */
bool		match(t_token *token, t_token_type expected[], int size);

/**
 * @brief Creates a new token with the specified type, string literal, and size
 *
 * @param l Pointer to a lexer structure (used for validation)
 * @param type The type of token to create
 * @param s String literal to associate with the token
 *
 * @return Pointer to the newly created token, or NULL if lexer is invalid or if memory allocation fails
 *
 * @note This function allocates memory for the token structure, but not for the string literal.
 *       The caller is responsible for managing the memory of the string passed in the 's' parameter.
 */
t_token		*new_tok(t_lexer *l, t_token_type type, char *s);
t_lexer		*new_lexer(const char *str);
void		free_lexer(t_lexer *l);
void		print_tokens(t_token *token);
char		*decode(t_token_type t);
bool		is_token_exec(t_token_type t);
// =====================================LEXER=====================================

// =====================================EXTRA=====================================
bool		is_letter(char c);
bool		ft_isspace(char ch);
int			is_there_exec(t_lexer *l);
// =====================================EXTRA=====================================

#endif
